diff --git a/internal/entryhuman/entry.go b/internal/entryhuman/entry.go
index d11db4f..14bb884 100644
--- a/internal/entryhuman/entry.go
+++ b/internal/entryhuman/entry.go
@@ -282,57 +282,37 @@ func Fmt(
 
 // OptimizedFmt returns a human readable format for ent. Assumes we have a bytes.Buffer
 // which we will more easily be able to assume underlying reallocation of it's size is possible
-// if neceesary than for an arbitrary io.Writer/io.StringWriter
+// if necessary than for an arbitrary io.Writer/io.StringWriter
+// Note that while bytes.Buffer can in theory return an error for writes, it only does so if the buffer size will
+// exceed our architectures max integer size. If the system is actually OOM and more memory cannot be allocated
+// it will panic instead.
 //
 // We never return with a trailing newline because Go's testing framework adds one
 // automatically and if we include one, then we'll get two newlines.
 // We also do not indent the fields as go's test does that automatically
 // for extra lines in a log so if we did it here, the fields would be indented
 // twice in test logs. So the Stderr logger indents all the fields itself.
-func OptimizedFmt(
-	buf *bytes.Buffer,
-	termW io.Writer,
-	ent slog.SinkEntry,
-) error {
-	writeString := func(s string) error {
-		_, err := buf.WriteString(s)
-		return err
-	}
-
+func OptimizedFmt(buf *bytes.Buffer, termW io.Writer, ent slog.SinkEntry) {
 	reset(buf, termW)
 
 	// Timestamp + space
-	if err := writeString(render(termW, timeStyle, ent.Time.Format(TimeFormat))); err != nil {
-		return err
-	}
-	if err := writeString(" "); err != nil {
-		return err
-	}
+	buf.WriteString(render(termW, timeStyle, ent.Time.Format(TimeFormat)+" "))
+	buf.WriteString("")
 
 	// Level label + two spaces
 	lvl := bracketedLevel(ent.Level) // e.g. "[debu]", "[info]"
-	if err := writeString(render(termW, levelStyle(ent.Level), lvl)); err != nil {
-		return err
-	}
-	if err := writeString("  "); err != nil {
-		return err
-	}
+	buf.WriteString(render(termW, levelStyle(ent.Level), lvl))
+	buf.WriteString("")
 
 	// Logger names: name1.name2.name3: (no strings.Join allocation)
 	if len(ent.LoggerNames) > 0 {
 		for i, name := range ent.LoggerNames {
 			if i > 0 {
-				if err := writeString("."); err != nil {
-					return err
-				}
-			}
-			if err := writeString(quoteKey(name)); err != nil {
-				return err
+				buf.WriteString(".")
 			}
+			buf.WriteString(quoteKey(name))
 		}
-		if err := writeString(": "); err != nil {
-			return err
-		}
+		buf.WriteString(": ")
 	}
 
 	// Message (detect multiline)
@@ -344,40 +324,22 @@ func OptimizedFmt(
 		multilineVal = msg
 		msg = quote("...")
 	}
-	if err := writeString(msg); err != nil {
-		return err
-	}
+	buf.WriteString(msg)
 
 	keyStyle := timeStyle
 	equalsStyle := timeStyle
 
 	// Write trace/span directly (do not mutate ent.Fields)
 	if ent.SpanContext.IsValid() {
-		if err := writeString(tab); err != nil {
-			return err
-		}
-		if err := writeString(render(termW, keyStyle, quoteKey("trace"))); err != nil {
-			return err
-		}
-		if err := writeString(render(termW, equalsStyle, "=")); err != nil {
-			return err
-		}
-		if err := writeString(ent.SpanContext.TraceID().String()); err != nil {
-			return err
-		}
+		buf.WriteString(tab)
 
-		if err := writeString(tab); err != nil {
-			return err
-		}
-		if err := writeString(render(termW, keyStyle, quoteKey("span"))); err != nil {
-			return err
-		}
-		if err := writeString(render(termW, equalsStyle, "=")); err != nil {
-			return err
-		}
-		if err := writeString(ent.SpanContext.SpanID().String()); err != nil {
-			return err
-		}
+		buf.WriteString(render(termW, keyStyle, quoteKey("trace")))
+		buf.WriteString(render(termW, equalsStyle, "="))
+		buf.WriteString(ent.SpanContext.TraceID().String())
+		buf.WriteString(tab)
+		buf.WriteString(render(termW, keyStyle, quoteKey("span")))
+		buf.WriteString(render(termW, equalsStyle, "="))
+		buf.WriteString(ent.SpanContext.SpanID().String())
 	}
 
 	// Find a multiline field without mutating ent.Fields.
@@ -409,84 +371,55 @@ func OptimizedFmt(
 			continue
 		}
 		if i < len(ent.Fields) {
-			if err := writeString(tab); err != nil {
-				return err
-			}
-		}
-		if err := writeString(render(termW, keyStyle, quoteKey(f.Name))); err != nil {
-			return err
-		}
-		if err := writeString(render(termW, equalsStyle, "=")); err != nil {
-			return err
+			buf.WriteString(tab)
 		}
 
+		buf.WriteString(render(termW, keyStyle, quoteKey(f.Name)))
+		buf.WriteString(render(termW, equalsStyle, "="))
+
 		if ok, err := writeValueFast(buf, f.Value); err != nil {
-			return err
+			// return err
 		} else if !ok {
-			if err := writeString(formatValue(f.Value)); err != nil {
-				return err
-			}
+			buf.WriteString(formatValue(f.Value))
 		}
 	}
 
 	// Multiline value block
 	if multilineVal != "" {
 		if msg != "..." {
-			if err := writeString(" ..."); err != nil {
-				return err
-			}
+			buf.WriteString(" ...")
 		}
 
-		if err := writeString("\n"); err != nil {
-			return err
-		}
-		if err := writeString(render(termW, keyStyle, multilineKey)); err != nil {
-			return err
-		}
-		if err := writeString("= "); err != nil {
-			return err
-		}
+		buf.WriteString("\n")
+		buf.WriteString(render(termW, keyStyle, multilineKey))
+		buf.WriteString("= ")
 
 		// First line up to first newline
 		s := multilineVal
 		if n := strings.IndexByte(s, '\n'); n >= 0 {
-			if err := writeString(s[:n]); err != nil {
-				return err
-			}
+			buf.WriteString(s[:n])
 			s = s[n+1:]
 		} else {
-			if err := writeString(s); err != nil {
-				return err
-			}
+			buf.WriteString(s)
 			s = ""
 		}
 
 		indent := strings.Repeat(" ", len(multilineKey)+2)
 		for len(s) > 0 {
-			if err := writeString("\n"); err != nil {
-				return err
-			}
+			buf.WriteString("\n")
 			// Only indent non-empty lines.
 			if s[0] != '\n' {
-				if err := writeString(indent); err != nil {
-					return err
-				}
+				buf.WriteString(indent)
 			}
 			if n := strings.IndexByte(s, '\n'); n >= 0 {
-				if err := writeString(s[:n]); err != nil {
-					return err
-				}
+				buf.WriteString(s[:n])
 				s = s[n+1:]
 			} else {
-				if err := writeString(s); err != nil {
-					return err
-				}
+				buf.WriteString(s)
 				break
 			}
 		}
 	}
-
-	return nil
 }
 
 var (
diff --git a/internal/entryhuman/entry_test.go b/internal/entryhuman/entry_test.go
index b791b6d..87e3435 100644
--- a/internal/entryhuman/entry_test.go
+++ b/internal/entryhuman/entry_test.go
@@ -411,10 +411,7 @@ func TestEntry_Optimized(t *testing.T) {
 			var optBuf bytes.Buffer
 
 			entryhuman.Fmt(&fmtBuf, io.Discard, tc.ent)
-			err := entryhuman.OptimizedFmt(&optBuf, io.Discard, tc.ent)
-			if err != nil {
-				t.Fatal(err)
-			}
+			entryhuman.OptimizedFmt(&optBuf, io.Discard, tc.ent)
 
 			assert.Equal(t, "outputs match", fmtBuf.String(), optBuf.String())
 		})
